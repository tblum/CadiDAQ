#include <settings.hpp>

#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>   // std::hex
#include <stdexcept> // exceptions
#include <iterator>  // distance

// BOOST
#include <boost/property_tree/ptree.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/predicate.hpp> // boost::starts_with
#include <boost/foreach.hpp>
// logging
#include <boost/log/attributes/attribute.hpp>
#include <boost/log/attributes/attribute_cast.hpp>
#include <boost/log/attributes/attribute_value.hpp>
#include <boost/log/attributes/constant.hpp>

#include <boolTranslator.hpp> // changes 'bool' interpretation in ptrees
#include <hexTranslator.hpp>  // changes 'int' interpretation in ptrees to allow reading hex strings
#include <CaenEnum2strTranslator.hpp> // adds CAEN enum types interpretation in ptrees

#include <CaenEnum2str.hpp> // generated by CMake in build directory
#include <helper.hpp>       // helper functions

#define CFG_LOG_DEBUG                                           \
  BOOST_LOG_CHANNEL_SEV(lg, "cfg", boost::log::trivial::debug)
#define CFG_LOG_INFO                                          \
  BOOST_LOG_CHANNEL_SEV(lg, "cfg", boost::log::trivial::info)
#define CFG_LOG_WARN                                              \
  BOOST_LOG_CHANNEL_SEV(lg, "cfg", boost::log::trivial::warning)
#define CFG_LOG_ERROR                                           \
  BOOST_LOG_CHANNEL_SEV(lg, "cfg", boost::log::trivial::error)
#define CFG_LOG_FATAL                                           \
  BOOST_LOG_CHANNEL_SEV(lg, "cfg", boost::log::trivial::fatal)

//
// Helper functions
//

/** describes valid values for the given variable.
    uses template specialization to cover CAEN enums, ints, bools */
template <typename CAEN_ENUM>
std::string describeValidValues(){
  // get a converter for this CAEN enum type
  cadidaq::CaenEnum2str enumConverter;
  CAEN_ENUM e;
  auto* map = enumConverter.getBimap(e);
  // generate a string of known options from the CAEN enum map
  std::stringstream knownOptions;
  std::string enumRoot = findEnumRoot(*map);
  typedef typename boost::bimap< std::string, CAEN_ENUM >::left_const_iterator const_iterator;
  for( const_iterator i = map->left.begin(), iend = map->left.end(); i != iend; ++i ){
    knownOptions << boost::erase_head_copy(i->first, enumRoot.length());
    if (!is_last(i, map->left)) knownOptions << ", ";
  }
  return knownOptions.str();
}
template <>
std::string describeValidValues<uint32_t>(){
  return std::string("32-bit wide integer in base 10 or hex notation with '0x' prefix");
}
template <>
std::string describeValidValues<int>(){
  return std::string("integer in base 10 or hex notation with '0x' prefix");
}
template <>
std::string describeValidValues<bool>(){
  return std::string("boolean value noted as either 0/1 or true/false");
}

//
// Class implementation
//

cadidaq::settingsBase::settingsBase(std::string name) : name(name)
{
  // Register a constant attribute that identifies our digitizer in the logs
  lg.add_attribute("Digitizer", boost::log::attributes::constant<std::string>(name));
}

void cadidaq::settingsBase::print(){
  // convert all settings to a PTree
  pt::iptree *node = createPTree();
  /* Loop over all sub sections and keys */
  for (auto& key : *node){
    CFG_LOG_INFO << "\t" << key.first << " = " << key.second.get_value<std::string>();
  }
  delete node;
};

void cadidaq::settingsBase::parse(pt::iptree *node){
  processPTree(node, parseDirection::READING);
}

pt::iptree* cadidaq::settingsBase::createPTree(){
  pt::iptree *node = new pt::iptree();
  processPTree(node, parseDirection::WRITING);
  return node;
}

void cadidaq::settingsBase::fillPTree(pt::iptree *node){
  processPTree(node, parseDirection::WRITING);
}

template <class VALUE> void cadidaq::settingsBase::parseSetting(std::string settingName, pt::iptree *node, boost::optional<VALUE>& settingValue, parseDirection direction, parseFormat format){
  if (direction == parseDirection::READING){
    // get the setting's value from the ptree
    try{
      settingValue = node->get<VALUE>(settingName);
    }
    catch (const pt::ptree_bad_data& e){
      CFG_LOG_ERROR << "Parsing '" << settingName << "' yielded Bad_Data exception (" << e.what() << ") for value: " << node->get<std::string>(settingName);
      CFG_LOG_ERROR << "\t Allowed values are: " << describeValidValues<VALUE>();
      return;
    }
    catch (const pt::ptree_bad_path& e){
      CFG_LOG_DEBUG << "Could not find key '" << settingName << "'";
      return;
    }
    if (settingValue) {
      CFG_LOG_DEBUG << "found key " << settingName << " with value '" << *settingValue << "' converted from string '" << node->get<std::string>(settingName) << "'";
    }
    // erase value from ptree as it has been successfully parsed
    // NOTE: this will only erase a single instance of the key; if the key exists several times, the other entries remain!
    node->erase(settingName);
  } else {
    // direction: WRITING
    // add key to ptree if the setting's value has been set
    if (settingValue) {
      if (format == parseFormat::HEX){
        std::stringstream ss;
        ss << std::hex << std::showbase << settingValue; // might need e.g. std::setfill ('0') and std::setw(sizeof(your_type)*2)
        node->put(settingName, ss.str());
      } else {
        node->put(settingName, *settingValue);
      }
    } else {
      CFG_LOG_DEBUG << "Value for '" << settingName << "' not defined when writing configuration. Setting will be omitted in output.";
    }
  }
}


template <typename VALUE> void cadidaq::settingsBase::parseSetting(std::string settingName, pt::iptree *node, std::vector<boost::optional<VALUE>>& settingValue, parseDirection direction, parseFormat format){
  if (direction == parseDirection::READING){
    std::vector<std::string> matchingKeys;
    // get the setting's value from the ptree by looping over all entries of "settingName[RANGE]"
    for (auto&& key : *node)
      if (boost::istarts_with(key.first, settingName))
        matchingKeys.push_back(key.first);

    if (matchingKeys.empty()){
      CFG_LOG_DEBUG << "Found no matching keys for setting " << settingName;
      return;
    } else
      CFG_LOG_DEBUG << "Found " << matchingKeys.size() << " matching keys for setting '" << settingName << "'";

    for (auto&& it : matchingKeys){
      // extract the range
      std::string range = boost::erase_head_copy(it, settingName.length());
      // remove the brackets or parenthesis and any remaining whitespace
      boost::trim_left_if(range,boost::is_any_of("[("));
      boost::trim_right_if(range,boost::is_any_of(")]"));
      // make sure that there are no characters present that we can't parse
      if (!boost::all(range,boost::is_any_of(",-*")||boost::is_digit() || boost::is_space())){
        CFG_LOG_ERROR << "Could not parse range '" << range << "' specified in setting '" << it << "'. Only allowed characters are '*', '-', ',' and digits.";
        continue;
      }
      // now split the range into individual channel numbers
      std::vector<int> v;
      // special treatment if the remaining character is an asterix
      if (boost::find_first(range,"*")){
        // use setting for all channels
        for (int i = 0; i < settingValue.size(); i++) v.push_back(i);
        CFG_LOG_DEBUG << "   Found '*' in range -> using settings's value for all channels";
      } else {
        // parse the range
        v = expandRange(range);
      }

      // output the parsed range for debugging purposes
      std::stringstream expandedrange;
      for(auto x:v)
        expandedrange << std::to_string(x) << " ";
      CFG_LOG_DEBUG << "   Expanded range '" << range << "' into " << expandedrange.str();

      // loop over parsed range and set the values in the settings vector
      boost::optional<VALUE> value;
      parseSetting(it, node, value, direction);
      if (!value) continue; // value not valid, try next key
      for(auto x:v){
        try{
          settingValue.at(x) = *value;
        }
        catch (const std::out_of_range& e) {
          CFG_LOG_ERROR << "Channel number '" << std::to_string(x) << "' in setting '" << settingName << "' is out of range!";
          continue;
        }
      }
    } // matchingKeys
  } else {
    // direction: WRITING
    // TODO: write range compression to get setting string as in "settingName[RANGE]"
    // add key to ptree if the setting's value has been set
    for (auto it = settingValue.begin(); it != settingValue.end(); ++it) {
      auto index = std::distance(settingValue.begin(), it);
      if (*it) {
        if (format == parseFormat::HEX){
          std::stringstream ss;
          ss << std::hex << std::showbase << **it; // might need e.g. std::setfill ('0') and std::setw(sizeof(your_type)*2)
          node->put(settingName + "[" + std::to_string(index) + "]", ss.str());
        } else {
          node->put(settingName + "[" + std::to_string(index) + "]", **it);
        }
      } else {
        // TODO: this log messages should be degraded to 'debug' at a later
        // stage when we are confident in the correct parsing of all parameters
        // for all different models and FW versions
        CFG_LOG_DEBUG << "Value for '" << settingName << "' not defined for channel #" << std::to_string(index) << " when writing configuration. Setting will be omitted in output.";
      }
    }
  }
}


void cadidaq::settingsBase::parseRegisters(pt::iptree *node, std::vector< std::pair< uint32_t, uint32_t >>& registers, parseDirection direction){
  std::string settingName = "SetRegister";
  if (direction == parseDirection::READING){
    std::vector<std::string> matchingKeys;
    // get the setting's value from the ptree by looping over all entries of "settingName[RANGE]"
    for (auto&& key : *node)
      if (boost::istarts_with(key.first, settingName))
        matchingKeys.push_back(key.first);

    if (matchingKeys.empty()){
      CFG_LOG_DEBUG << "Found no matching keys for setting " << settingName;
      return;
    } else
      CFG_LOG_DEBUG << "Found " << matchingKeys.size() << " matching keys for setting '" << settingName << "'";

    for (auto&& it : matchingKeys){
      // extract the range
      std::string address = boost::erase_head_copy(it, settingName.length());
      // remove the brackets or parenthesis and any remaining whitespace
      boost::trim_left_if(address,boost::is_any_of("[("));
      boost::trim_right_if(address,boost::is_any_of(")]"));
      // make sure that there are no characters present that we can't parse
      if (!boost::all(address,boost::is_any_of("x,")||boost::is_digit() || boost::is_space())){
        CFG_LOG_ERROR << "Could not parse register address '" << address << "' specified in setting '" << it << "'. Only allowed characters are comma-separated hex values.";
        continue;
      }
      // retrieve the key's value
      boost::optional<uint32_t> value;
      parseSetting(it, node, value, direction);
      if (!value) continue; // value not valid, try next key

      // now split the potentially comma-separated address(es) into individual
      // addresses and keep the address-value pair in the given vector
      std::vector<std::string> strs;
      boost::split(strs,address,boost::is_any_of(","));
      // expand values
      for (auto it:strs){
        boost::optional<uint32_t> adr = str2hex(it);
        if (!adr){
          CFG_LOG_ERROR << "Could not convert register address '" << it << "' to a number. Only allowed characters are comma-separated hex values.";
          continue;
        }
        registers.push_back(std::make_pair(*adr, *value));
        CFG_LOG_DEBUG << "   Parsed config value '" << std::hex << std::showbase << *value <<  "' for register address " << *adr;
      }
    } // matchingKeys
  } else {
    // direction: WRITING
    for (auto it = registers.begin(); it != registers.end(); ++it) {
      std::stringstream v;
      std::stringstream s;
      s << settingName << "[" << std::hex << std::showbase << it->first << "]";
      v << std::hex << std::showbase << it->second;
      node->put(s.str(), v.str());
    }
  }
}


template <class VALUE> void cadidaq::settingsBase::parseSetting(option<VALUE>& setting, pt::iptree *node, parseDirection direction, parseFormat format){
  parseSetting(setting.second, node, setting.first, direction, format);
}
template <typename VALUE> void cadidaq::settingsBase::parseSetting(optionVector<VALUE>& setting, pt::iptree *node, parseDirection direction, parseFormat format){
  parseSetting(setting.second, node, setting.first, direction, format);
}


void cadidaq::connectionSettings::verify(){

  if (!linkType){
    CFG_LOG_ERROR << "Missing (or invalid) non-optional setting 'LinkType' in section '" << name << "'";
    throw std::invalid_argument(std::string("Missing (or invalid) setting for 'LinkType'"));
  }
  if (*linkType == CAEN_DGTZ_USB){
    if (conetNode && *conetNode != 0){
      CFG_LOG_DEBUG << "When using LinkType=USB, ConetNode needs to be '0'! Fixed.";
    }
    // set the correct values for the chosen linktype
    conetNode = 0;
  }
  if (!vmeBaseAddress){
    CFG_LOG_DEBUG << "VMEBaseAddress connection option not set, assuming '0'";
    vmeBaseAddress = 0;
  }
  if (!linkNum){
    CFG_LOG_WARN << "LinkNum connection option not set, assuming '0'";
    linkNum = 0;
  }
  CFG_LOG_DEBUG << "Done with verifying connection settings.";
}

void cadidaq::connectionSettings::processPTree(pt::iptree *node, parseDirection direction){
    // this routine implements the calls to ParseSetting for individual settings read from config or stored internally

    parseSetting("LinkType", node, linkType, direction);
    parseSetting("LinkNum", node, linkNum, direction);
    parseSetting("ConetNode", node, conetNode, direction);
    parseSetting("VMEBaseAddress", node, vmeBaseAddress, direction, parseFormat::HEX);
    CFG_LOG_DEBUG << "Done with processing connection settings ptree";

  }


cadidaq::registerSettings::registerSettings(std::string name, uint nchannels) : cadidaq::settingsBase(name) {
  // data readout
  maxNumEventsBLT     = std::make_pair(boost::none, "Expert_MaxNumEventsBLT");

  // trigger settings
  swTriggerMode       = std::make_pair(boost::none, "SWTriggerMode");
  externalTriggerMode = std::make_pair(boost::none, "ExternalTriggerMode");
  ioLevel             = std::make_pair(boost::none, "IOLevel");
  chSelfTrigger       = std::make_pair(Vec<CAEN_DGTZ_TriggerMode_t>(nchannels), "ChannelSelfTrigger");
  chTriggerThreshold  = std::make_pair(Vec<uint32_t>(nchannels), "ChannelTriggerTreshold");
  chTriggerPolarity   = std::make_pair(Vec<CAEN_DGTZ_TriggerPolarity_t>(nchannels), "ChannelTriggerPolarity");
  runSyncMode         = std::make_pair(boost::none, "RunSynchronizationMode");
  outSignalMode       = std::make_pair(boost::none, "OutputSignalMode");

  // acquisition settings
  acquisitionMode     = std::make_pair(boost::none, "AcquisitionMode");
  recordLength        = std::make_pair(boost::none, "RecordLength");
  postTriggerSize     = std::make_pair(boost::none, "PostTriggerSize");
  chEnable            = std::make_pair(Vec<bool>(nchannels), "EnableChannel");
  chDCOffset          = std::make_pair(Vec<uint32_t>(nchannels), "ChannelDCOffset");
  desMode             = std::make_pair(boost::none, "DESMode");

  // DPP-FW settings
  dppPreTriggerSize   = std::make_pair(Vec<uint32_t>(nchannels), "DPPPreTriggerSize");
  dppChPulsePolarity  = std::make_pair(Vec<CAEN_DGTZ_PulsePolarity_t>(nchannels), "DPPChannelPulsePolarity");
  dppAcqMode = std::make_pair(boost::none, "DPPAcquisitionMode");
  dppTriggermode      = std::make_pair(boost::none, "DPPTriggerMode");

}



void cadidaq::registerSettings::processPTree(pt::iptree *node, parseDirection direction){
  // this routine implements the calls to ParseSetting for individual settings read from config or stored internally

  // data readout
  parseSetting(maxNumEventsBLT, node, direction);

  // trigger
  parseSetting(swTriggerMode, node, direction);
  parseSetting(externalTriggerMode, node, direction);
  parseSetting(ioLevel, node, direction);
  parseSetting(chSelfTrigger, node, direction);
  parseSetting(chTriggerThreshold, node, direction);
  parseSetting(chTriggerPolarity, node, direction);
  parseSetting(runSyncMode, node, direction);
  parseSetting(outSignalMode, node, direction);

  // acquisition
  parseSetting(recordLength, node, direction);
  parseSetting(postTriggerSize, node, direction);
  parseSetting(acquisitionMode, node, direction);
  parseSetting(chEnable, node, direction);
  parseSetting(chDCOffset, node, direction);
  parseSetting(desMode, node, direction);

  // DPP-FW
  parseSetting(dppPreTriggerSize, node, direction);
  parseSetting(dppChPulsePolarity, node, direction);
  //parseSetting(dppAcqMode, node, direction);
  parseSetting(dppTriggermode, node, direction);

  // register address-value settings
  parseRegisters(node, registerValues, direction);

  CFG_LOG_DEBUG << "Done with processing register settings property tree";

}


void cadidaq::registerSettings::verify(){
  // TODO: implement "light" checks on e.g. critical options that are valid for all supported digitizer types/families (nothing model-dependent)

  // check that at least one channel is set to enable
  if (countTrue(chEnable.first) == 0)
    CFG_LOG_WARN << "No channel has been set to be enabled using setting '" << chEnable.second << "'!";
  else
    CFG_LOG_DEBUG << "Setting '" << chEnable.second << "' enables " << countTrue(chEnable.first) << " channels.";

  // DPPAcquisitionMode requires two parameters to be set
/*  if ((dppAcqMode.first && !dppAcqModeParam.first) || (!dppAcqMode.first && dppAcqModeParam.first)){
    CFG_LOG_ERROR << "DPPAcquisitionMode requires two arguments and is missing either " << dppAcqMode.second << " or " << dppAcqModeParam.second << ". Cannot configure option!";
    // for consistency, set the option to be ignored later
    dppAcqMode.first = boost::none;
    dppAcqModeParam.first = boost::none;
  }*/

  CFG_LOG_DEBUG << "Done with verifying register settings.";
}
